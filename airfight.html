<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Air Fight Game</title>
    <style>
        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 50%, #0f3460 100%);
            font-family: 'Arial', sans-serif;
            margin: 0;
            padding: 0;
            overflow: hidden;
        }

        .home-btn {
            background: linear-gradient(45deg, #2196F3, #03A9F4);
            font-size: 20px;
            padding: 12px 30px;
            position: fixed;
            top: 20px;
            left: 20px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
            color: white;
            text-decoration: none;
            z-index: 1000;
        }

        .home-btn:hover {
            background: linear-gradient(45deg, #1976D2, #0288D1);
            transform: scale(1.05);
        }

        #gameCanvas {
            display: block;
            margin: 0 auto;
            background: linear-gradient(180deg, #0a1128 0%, #001f54 100%);
            border: 3px solid #00d4ff;
            box-shadow: 0 0 30px rgba(0, 212, 255, 0.5);
        }

        .game-info {
            position: absolute;
            top: 20px;
            right: 20px;
            color: white;
            font-size: 24px;
            text-shadow: 2px 2px 5px rgba(0,0,0,0.8);
            z-index: 100;
        }

        .shield-bar {
            width: 200px;
            height: 20px;
            background: rgba(0,0,0,0.5);
            border: 2px solid #00d4ff;
            border-radius: 10px;
            margin-top: 5px;
            overflow: hidden;
        }

        .shield-fill {
            height: 100%;
            background: linear-gradient(90deg, #00d4ff, #00ffff);
            transition: width 0.3s;
        }

        h1 {
            text-align: center;
            color: #00d4ff;
            font-size: 48px;
            text-shadow: 0 0 20px rgba(0, 212, 255, 0.8);
            margin: 20px 0;
        }

        .game-over-screen {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            background: rgba(0, 0, 0, 0.9);
            padding: 40px;
            border-radius: 20px;
            text-align: center;
            display: none;
            z-index: 200;
        }

        .game-over-screen h2 {
            color: #ff4444;
            font-size: 48px;
            margin: 0 0 20px 0;
        }

        .game-over-screen p {
            color: white;
            font-size: 24px;
            margin: 10px 0;
        }

        .game-over-screen button {
            background: linear-gradient(45deg, #00ff87, #60efff);
            color: #1a1a1a;
            font-size: 24px;
            padding: 15px 40px;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            margin-top: 20px;
        }

        .game-over-screen button:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <a href="index.html" style="text-decoration: none;">
        <button class="home-btn">üè† Back to Home</button>
    </a>

    <h1>‚úàÔ∏è Air Fight ‚úàÔ∏è</h1>

    <div class="game-info">
        <div>Score: <span id="score">0</span></div>
        <div>Health: <span id="health">100</span></div>
        <div id="shieldContainer" style="display: none;">
            Shield: <span id="shield">0</span>
            <div class="shield-bar">
                <div class="shield-fill" id="shieldFill" style="width: 0%"></div>
            </div>
        </div>
        <div id="missileContainer" style="display: none;">
            Missiles: üöÄ <span id="missileCountDisplay">0</span>
            <span id="missilePrompt" style="color: #ffff00; margin-left: 10px; display: none;">Press SPACE to shoot</span>
        </div>
    </div>

    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <div class="game-over-screen" id="gameOver">
        <h2>Game Over!</h2>
        <p>Final Score: <span id="finalScore">0</span></p>
        <button onclick="restartGame()">Play Again</button>
    </div>

    <script>
        const canvas = document.getElementById('gameCanvas');
        const ctx = canvas.getContext('2d');

        let player = {
            x: canvas.width / 2 - 25,
            y: canvas.height - 80,
            width: 50,
            height: 50,
            speed: 3,
            color: '#00ff87'
        };

        let bullets = [];
        let enemies = [];
        let enemyBullets = [];
        let powerups = [];
        let wingplanes = [];
        let score = 0;
        let health = 100;
        let shield = 0;
        let gameRunning = true;
        let keys = {};
        let autoFireInterval = null;
        let scoreInterval = null;
        let fireRate = 200;
        let tripleShot = false;
        let forkShot = false;
        let collectedBuffTypes = new Set();
        let buffCollectionCount = { A: 0, B: 0, C: 0, D: 0, F: 0 };
        let cheatCode = '';
        let cheatTimeout = null;
        let bomberPlanes = [];
        let explosions = [];
        let boss = null;
        let bossSpawned = false;
        let missileCount = 0;
        let missiles = [];
        let missileParticles = [];
        let hasShownMissilePrompt = false;

        // Controls
        document.addEventListener('keydown', (e) => {
            keys[e.key] = true;
            if (e.key === ' ' && gameRunning) {
                if (missileCount > 0) {
                    shootMissiles();
                } else {
                    shootBullet();
                }
            }

            // Score cheat key
            if (e.key === '0' && gameRunning) {
                score += 15000;
                document.getElementById('score').textContent = score;
            }

            // Cheat code detection
            const key = e.key.toLowerCase();
            if (['c', 'h', 'e', 'a', 't'].includes(key)) {
                cheatCode += key;

                clearTimeout(cheatTimeout);
                cheatTimeout = setTimeout(() => {
                    cheatCode = '';
                }, 2000);

                if (cheatCode === 'cheat') {
                    cheatCode = '';
                    activateCheat();
                }
            } else {
                cheatCode = '';
            }
        });

        document.addEventListener('keyup', (e) => {
            keys[e.key] = false;
        });

        function shootBullet() {
            const bulletWidth = 5;
            const bulletHeight = 15;

            if (forkShot) {
                // Fork pattern: 4 bullets in a spread
                const angles = [-10, -3.5, 3.5, 10]; // degrees
                angles.forEach(angle => {
                    const radians = angle * Math.PI / 180;
                    bullets.push({
                        x: player.x + player.width / 2 - bulletWidth / 2,
                        y: player.y,
                        width: bulletWidth,
                        height: bulletHeight,
                        speed: 7,
                        velocityX: Math.sin(radians) * 7,
                        velocityY: -Math.cos(radians) * 7,
                        color: '#ffff00',
                        angled: true
                    });
                });
            } else if (tripleShot) {
                // Center bullet
                bullets.push({
                    x: player.x + player.width / 2 - bulletWidth / 2,
                    y: player.y,
                    width: bulletWidth,
                    height: bulletHeight,
                    speed: 7,
                    color: '#ffff00'
                });
                // Left bullet
                bullets.push({
                    x: player.x + player.width / 2 - 15 - bulletWidth / 2,
                    y: player.y,
                    width: bulletWidth,
                    height: bulletHeight,
                    speed: 7,
                    color: '#ffff00'
                });
                // Right bullet
                bullets.push({
                    x: player.x + player.width / 2 + 10 - bulletWidth / 2,
                    y: player.y,
                    width: bulletWidth,
                    height: bulletHeight,
                    speed: 7,
                    color: '#ffff00'
                });
            } else {
                bullets.push({
                    x: player.x + player.width / 2 - bulletWidth / 2,
                    y: player.y,
                    width: bulletWidth,
                    height: bulletHeight,
                    speed: 7,
                    color: '#ffff00'
                });
            }
        }

        function createEnemy() {
            const rand = Math.random();
            let enemyType = 'normal';

            // Determine enemy type based on score
            if (score >= 3000 && rand < 0.15) {
                enemyType = 'tank'; // 15% chance at 3000+ score
            } else if (score >= 2000 && rand < 0.2) {
                enemyType = 'fast'; // 20% chance at 2000+ score
            } else if (score >= 1000 && rand < 0.3) {
                enemyType = 'shooter'; // 30% chance at 1000+ score
            }

            // Enemies require 2 hits at 6000+ score
            const baseHealth = score >= 6000 ? 2 : 1;

            if (enemyType === 'tank') {
                // Tank enemy: Slow, large, high HP
                const tankHealth = score >= 6000 ? 40 : 20;
                enemies.push({
                    x: Math.random() * (canvas.width - 60),
                    y: -70,
                    width: 60,
                    height: 60,
                    speed: 0.5,
                    horizontalSpeed: (Math.random() - 0.5) * 0.8,
                    color: '#8800ff',
                    canShoot: false,
                    type: 'tank',
                    health: tankHealth,
                    maxHealth: tankHealth,
                    lastShot: 0
                });
            } else if (enemyType === 'fast') {
                // Fast enemy: Quick zigzag movement
                enemies.push({
                    x: Math.random() * (canvas.width - 30),
                    y: -40,
                    width: 30,
                    height: 30,
                    speed: 2.5,
                    horizontalSpeed: (Math.random() - 0.5) * 4,
                    color: '#00ffff',
                    canShoot: false,
                    type: 'fast',
                    health: baseHealth,
                    maxHealth: baseHealth,
                    lastShot: 0
                });
            } else if (enemyType === 'shooter') {
                // Shooter enemy: Fires at player
                const shootChance = 0.2 + Math.min((score - 1000) / 10000, 0.3);
                enemies.push({
                    x: Math.random() * (canvas.width - 40),
                    y: -50,
                    width: 40,
                    height: 40,
                    speed: 1 + Math.random() * 1,
                    horizontalSpeed: (Math.random() - 0.5) * 2,
                    color: '#ff9900',
                    canShoot: true,
                    type: 'shooter',
                    health: baseHealth,
                    maxHealth: baseHealth,
                    lastShot: 0
                });
            } else {
                // Normal enemy
                enemies.push({
                    x: Math.random() * (canvas.width - 40),
                    y: -50,
                    width: 40,
                    height: 40,
                    speed: 1 + Math.random() * 1,
                    horizontalSpeed: (Math.random() - 0.5) * 2,
                    color: '#ff4444',
                    canShoot: false,
                    type: 'normal',
                    health: baseHealth,
                    maxHealth: baseHealth,
                    lastShot: 0
                });
            }
        }

        function createPowerup() {
            const types = ['A', 'B', 'C', 'D', 'F'];
            const colors = ['#00ffff', '#ff00ff', '#00ff00', '#ffaa00', '#ffff00'];

            // Calculate weighted probabilities based on collected buffs
            let weights = types.map(type => {
                // Base weight is 1
                let weight = 1;
                // If this type hasn't been collected, increase weight
                if (!collectedBuffTypes.has(type)) {
                    weight *= 2;
                }
                return weight;
            });

            // Weighted random selection
            const totalWeight = weights.reduce((sum, w) => sum + w, 0);
            let random = Math.random() * totalWeight;
            let selectedIndex = 0;

            for (let i = 0; i < weights.length; i++) {
                random -= weights[i];
                if (random <= 0) {
                    selectedIndex = i;
                    break;
                }
            }

            const type = types[selectedIndex];
            powerups.push({
                x: Math.random() * (canvas.width - 30),
                y: -30,
                width: 30,
                height: 30,
                speed: 2,
                type: type,
                color: colors[types.indexOf(type)]
            });
        }

        function updatePowerups() {
            powerups = powerups.filter(powerup => {
                powerup.y += powerup.speed;

                // Check collision with player
                if (checkCollision(player, powerup)) {
                    activatePowerup(powerup.type);
                    collectedBuffTypes.add(powerup.type);
                    buffCollectionCount[powerup.type]++;
                    return false;
                }

                // Check collision with wingplanes
                for (let i = 0; i < wingplanes.length; i++) {
                    if (!wingplanes[i].spawning && checkCollision(wingplanes[i], powerup)) {
                        activatePowerup(powerup.type);
                        collectedBuffTypes.add(powerup.type);
                        buffCollectionCount[powerup.type]++;
                        return false;
                    }
                }

                return powerup.y < canvas.height;
            });
        }

        function activatePowerup(type) {
            if (type === 'A') {
                // Increase shooting speed - stackable, max 3 times
                if (buffCollectionCount.A <= 3) {
                    fireRate = Math.max(50, fireRate - 30);
                    startAutoFire();
                }
            } else if (type === 'B') {
                // Triple shot on first collect, fork shot on second collect
                if (buffCollectionCount.B === 0) {
                    tripleShot = true;
                } else if (buffCollectionCount.B >= 1) {
                    forkShot = true;
                    tripleShot = false; // Replace triple shot with fork shot
                }
            } else if (type === 'C') {
                // Restore health and add shield - stackable shield
                health = Math.min(100, health + 50);
                shield = Math.min(200, shield + 50);
                document.getElementById('health').textContent = health;
                updateShieldDisplay();
            } else if (type === 'D') {
                // Spawn wingplanes or bomber planes
                if (wingplanes.length < 2) {
                    // Missing wingplanes, spawn regular ones
                    const missingSide = determineMissingSide();
                    if (missingSide === 'both') {
                        spawnWingplanes();
                    } else {
                        // Spawn one regular wingplane on missing side
                        spawnSingleWingplane(missingSide);
                        // Spawn one bomber plane on opposite side
                        spawnBomberPlane(missingSide === 'left' ? 'right' : 'left');
                    }
                } else {
                    // Already have 2 wingplanes, spawn 2 bomber planes
                    spawnBomberPlane('left');
                    spawnBomberPlane('right');
                }
            } else if (type === 'F') {
                // Missile system - 5 shots, each shoots 3 homing missiles
                // Can stack up to 10 total
                missileCount = Math.min(missileCount + 5, 10);
                updateMissileDisplay();
            }
        }

        function updateMissileDisplay() {
            const missileContainer = document.getElementById('missileContainer');
            const missileCountDisplay = document.getElementById('missileCountDisplay');
            const missilePrompt = document.getElementById('missilePrompt');

            if (missileCount > 0) {
                missileContainer.style.display = 'block';
                missileCountDisplay.textContent = missileCount;

                // Show prompt only the first time player gets missiles
                if (!hasShownMissilePrompt) {
                    missilePrompt.style.display = 'inline';
                    hasShownMissilePrompt = true;
                }
            } else {
                missileContainer.style.display = 'none';
                missilePrompt.style.display = 'none';
            }
        }

        function shootMissiles() {
            if (missileCount <= 0) return;

            // Shoot 4 missiles with horizontal spread
            const spreadAngles = [-30, -10, 10, 30]; // Horizontal injection angles
            for (let i = 0; i < 4; i++) {
                // Find a random target (enemy or boss)
                let target = null;
                const allTargets = [...enemies];
                if (boss) allTargets.push(boss);

                if (allTargets.length > 0) {
                    // Random target selection for each missile
                    target = allTargets[Math.floor(Math.random() * allTargets.length)];
                }

                const angleRad = spreadAngles[i] * Math.PI / 180;
                const currentTime = Date.now();

                missiles.push({
                    x: player.x + player.width / 2,
                    y: player.y,
                    width: 12,
                    height: 24,
                    speed: 2,
                    maxSpeed: 4,
                    acceleration: 0.03,
                    velocityX: Math.sin(angleRad) * 2, // Horizontal spread
                    velocityY: -Math.cos(angleRad) * 1, // Start very slow
                    target: target,
                    trackingStrength: 0.15, // Lower tracking strength
                    color: '#ff0000',
                    trail: [],
                    spawnTime: currentTime
                });
            }

            missileCount--;
            updateMissileDisplay();
        }

        function updateMissiles() {
            const currentTime = Date.now();
            missiles = missiles.filter(missile => {
                // Remove missile after 2 seconds
                if (currentTime - missile.spawnTime >= 2000) {
                    return false;
                }

                // Update target if it's destroyed or track new random target
                if (missile.target && (missile.target.health === undefined || missile.target.health <= 0 || missile.target === null)) {
                    const allTargets = [...enemies];
                    if (boss) allTargets.push(boss);
                    if (allTargets.length > 0) {
                        missile.target = allTargets[Math.floor(Math.random() * allTargets.length)];
                    } else {
                        missile.target = null;
                    }
                }

                // Accelerate missile gradually
                const currentSpeed = Math.sqrt(missile.velocityX ** 2 + missile.velocityY ** 2);
                if (currentSpeed < missile.maxSpeed) {
                    missile.speed = Math.min(missile.speed + missile.acceleration, missile.maxSpeed);
                }

                // Homing behavior
                if (missile.target) {
                    const targetX = missile.target.x + missile.target.width / 2;
                    const targetY = missile.target.y + missile.target.height / 2;

                    const dx = targetX - missile.x;
                    const dy = targetY - missile.y;
                    const distance = Math.sqrt(dx * dx + dy * dy);

                    if (distance > 0) {
                        // Direct tracking without randomness
                        missile.velocityX += (dx / distance) * missile.trackingStrength;
                        missile.velocityY += (dy / distance) * missile.trackingStrength;
                    }
                }

                // Limit speed to current max
                const newSpeed = Math.sqrt(missile.velocityX ** 2 + missile.velocityY ** 2);
                if (newSpeed > missile.speed) {
                    missile.velocityX = (missile.velocityX / newSpeed) * missile.speed;
                    missile.velocityY = (missile.velocityY / newSpeed) * missile.speed;
                }

                // Update position
                missile.x += missile.velocityX;
                missile.y += missile.velocityY;

                // Add trail
                missile.trail.push({ x: missile.x, y: missile.y, opacity: 1 });
                if (missile.trail.length > 10) {
                    missile.trail.shift();
                }

                // Create particles
                if (Math.random() < 0.3) {
                    missileParticles.push({
                        x: missile.x,
                        y: missile.y,
                        vx: (Math.random() - 0.5) * 2,
                        vy: (Math.random() - 0.5) * 2,
                        life: 20,
                        maxLife: 20,
                        color: '#ff' + Math.floor(Math.random() * 100 + 155).toString(16) + '00'
                    });
                }

                // Check collision with enemies
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (checkCollision(missile, enemies[i])) {
                        const enemy = enemies[i];
                        const explosionX = enemy.x + enemy.width / 2;
                        const explosionY = enemy.y + enemy.height / 2;

                        // Missile destroys enemy instantly
                        enemies.splice(i, 1);

                        // Award points
                        if (enemy.type === 'tank') {
                            score += 75;
                        } else if (enemy.type === 'fast') {
                            score += 50;
                        } else {
                            score += 25;
                        }
                        document.getElementById('score').textContent = score;

                        // Create visual explosion (like bomber plane explosions)
                        explosions.push({
                            x: explosionX,
                            y: explosionY,
                            radius: 0,
                            maxRadius: 60,
                            opacity: 1,
                            startTime: Date.now()
                        });

                        // Create explosion particle effects
                        for (let j = 0; j < 25; j++) {
                            missileParticles.push({
                                x: explosionX,
                                y: explosionY,
                                vx: (Math.random() - 0.5) * 8,
                                vy: (Math.random() - 0.5) * 8,
                                life: 40,
                                maxLife: 40,
                                color: '#ff' + Math.floor(Math.random() * 155 + 100).toString(16) + '00'
                            });
                        }

                        return false; // Remove missile
                    }
                }

                // Check collision with boss
                if (boss && checkCollision(missile, boss)) {
                    const explosionX = missile.x;
                    const explosionY = missile.y;

                    boss.health -= 10; // Missile does 10 damage to boss

                    if (boss.health <= 0) {
                        score += 5000;
                        document.getElementById('score').textContent = score;
                        boss = null;
                        // Game over when boss is defeated
                        gameRunning = false;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('gameOver').style.display = 'flex';
                    }

                    // Create visual explosion
                    explosions.push({
                        x: explosionX,
                        y: explosionY,
                        radius: 0,
                        maxRadius: 50,
                        opacity: 1,
                        startTime: Date.now()
                    });

                    // Create explosion particle effects
                    for (let j = 0; j < 20; j++) {
                        missileParticles.push({
                            x: explosionX,
                            y: explosionY,
                            vx: (Math.random() - 0.5) * 7,
                            vy: (Math.random() - 0.5) * 7,
                            life: 35,
                            maxLife: 35,
                            color: '#ff' + Math.floor(Math.random() * 155 + 100).toString(16) + '00'
                        });
                    }

                    return false; // Remove missile
                }

                // Remove if off screen
                return missile.y > -20 && missile.y < canvas.height + 20 &&
                       missile.x > -20 && missile.x < canvas.width + 20;
            });
        }

        function updateMissileParticles() {
            missileParticles = missileParticles.filter(particle => {
                particle.x += particle.vx;
                particle.y += particle.vy;
                particle.life--;
                particle.vy += 0.1; // Gravity
                return particle.life > 0;
            });
        }

        function drawMissiles() {
            missiles.forEach(missile => {
                // Draw trail
                missile.trail.forEach((point, index) => {
                    const opacity = (index / missile.trail.length) * 0.5;
                    ctx.fillStyle = `rgba(255, 100, 0, ${opacity})`;
                    ctx.beginPath();
                    ctx.arc(point.x, point.y, 3, 0, Math.PI * 2);
                    ctx.fill();
                });

                // Draw missile body
                ctx.save();
                ctx.translate(missile.x, missile.y);
                const angle = Math.atan2(missile.velocityY, missile.velocityX) + Math.PI / 2;
                ctx.rotate(angle);

                // Missile body (bigger)
                ctx.fillStyle = '#ff0000';
                ctx.fillRect(-6, -12, 12, 24);

                // Missile tip
                ctx.fillStyle = '#ffff00';
                ctx.beginPath();
                ctx.moveTo(0, -12);
                ctx.lineTo(-6, -6);
                ctx.lineTo(6, -6);
                ctx.closePath();
                ctx.fill();

                // Missile fins
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(-9, 6, 4, 6);
                ctx.fillRect(5, 6, 4, 6);

                ctx.restore();

                // Glow effect (bigger)
                ctx.fillStyle = 'rgba(255, 100, 0, 0.3)';
                ctx.beginPath();
                ctx.arc(missile.x, missile.y, 15, 0, Math.PI * 2);
                ctx.fill();
            });

            // Draw particles
            missileParticles.forEach(particle => {
                const opacity = particle.life / particle.maxLife;
                ctx.fillStyle = particle.color.slice(0, 7) + Math.floor(opacity * 255).toString(16).padStart(2, '0');
                ctx.beginPath();
                ctx.arc(particle.x, particle.y, 2 + (1 - opacity) * 3, 0, Math.PI * 2);
                ctx.fill();
            });
        }

        function activateCheat() {
            if (!gameRunning) return;

            // Activate all buffs to max
            fireRate = 50; // Max fire rate
            forkShot = true;
            tripleShot = false;
            health = 100;
            shield = 200; // Max shield
            missileCount = 5; // Add missiles

            // Spawn wingplanes if not already present
            if (wingplanes.length === 0) {
                spawnWingplanes();
            }

            // Mark all buffs as collected
            collectedBuffTypes.add('A');
            collectedBuffTypes.add('B');
            collectedBuffTypes.add('C');
            collectedBuffTypes.add('D');
            collectedBuffTypes.add('F');

            // Set max collection counts
            buffCollectionCount = { A: 3, B: 2, C: 1, D: 1, F: 1 };

            // Update displays
            document.getElementById('health').textContent = health;
            updateShieldDisplay();
            updateMissileDisplay();
            startAutoFire();
        }

        function determineMissingSide() {
            const hasLeft = wingplanes.some(w => w.side === 'left');
            const hasRight = wingplanes.some(w => w.side === 'right');

            if (!hasLeft && !hasRight) return 'both';
            if (!hasLeft) return 'left';
            if (!hasRight) return 'right';
            return 'none';
        }

        function spawnWingplanes() {
            // Left wingplane
            wingplanes.push({
                x: player.x - 60,
                y: canvas.height + 50,
                targetY: player.y + 10,
                width: 35,
                height: 35,
                health: 1,
                side: 'left',
                color: '#ffaa00',
                spawning: true
            });
            // Right wingplane
            wingplanes.push({
                x: player.x + player.width + 25,
                y: canvas.height + 50,
                targetY: player.y + 10,
                width: 35,
                height: 35,
                health: 1,
                side: 'right',
                color: '#ffaa00',
                spawning: true
            });
        }

        function spawnSingleWingplane(side) {
            const xPos = side === 'left' ? player.x - 60 : player.x + player.width + 25;
            wingplanes.push({
                x: xPos,
                y: canvas.height + 50,
                targetY: player.y + 10,
                width: 35,
                height: 35,
                health: 1,
                side: side,
                color: '#ffaa00',
                spawning: true
            });
        }

        function spawnBomberPlane(side) {
            const xPos = side === 'left' ? 100 : canvas.width - 100;
            bomberPlanes.push({
                x: xPos,
                y: canvas.height + 50,
                width: 40,
                height: 40,
                speed: 3,
                side: side,
                color: '#ff00aa',
                lastBomb: Date.now()
            });
        }

        function updateBomberPlanes() {
            const currentTime = Date.now();
            bomberPlanes = bomberPlanes.filter(bomber => {
                // Move up through the screen
                bomber.y -= bomber.speed;

                // Drop bombs at 5 per second (200ms interval)
                if (currentTime - bomber.lastBomb >= 200) {
                    createExplosion(bomber.x + bomber.width / 2, bomber.y + bomber.height / 2);
                    bomber.lastBomb = currentTime;
                }

                // Remove when off screen
                return bomber.y > -bomber.height;
            });
        }

        function createExplosion(x, y) {
            const explosionRadius = 150; // Increased radius to damage enemies

            // Create visual explosion effect
            explosions.push({
                x: x,
                y: y,
                radius: 0,
                maxRadius: explosionRadius,
                opacity: 1,
                startTime: Date.now()
            });

            // Damage enemies in radius
            enemies = enemies.filter(enemy => {
                const enemyCenterX = enemy.x + enemy.width / 2;
                const enemyCenterY = enemy.y + enemy.height / 2;
                const distance = Math.sqrt(
                    Math.pow(enemyCenterX - x, 2) +
                    Math.pow(enemyCenterY - y, 2)
                );

                if (distance <= explosionRadius) {
                    // Tanks are instantly destroyed by bombs
                    if (enemy.type === 'tank') {
                        score += 75;
                        document.getElementById('score').textContent = score;
                        return false; // Remove tank
                    }

                    // Other enemies take damage
                    enemy.health -= 1;

                    if (enemy.health <= 0) {
                        // Award points based on enemy type
                        if (enemy.type === 'fast') {
                            score += 50;
                        } else {
                            score += 25;
                        }
                        document.getElementById('score').textContent = score;
                        return false; // Remove enemy
                    }
                }
                return true;
            });

            // Damage boss if in radius
            if (boss) {
                const bossCenterX = boss.x + boss.width / 2;
                const bossCenterY = boss.y + boss.height / 2;
                const distanceToBoss = Math.sqrt(
                    Math.pow(bossCenterX - x, 2) +
                    Math.pow(bossCenterY - y, 2)
                );

                if (distanceToBoss <= explosionRadius) {
                    boss.health -= 50; // Bombs deal 50 damage to boss

                    if (boss.health <= 0) {
                        score += 5000;
                        document.getElementById('score').textContent = score;
                        boss = null;
                        // Game over when boss is defeated
                        gameRunning = false;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('gameOver').style.display = 'flex';
                    }
                }
            }
        }

        function updateExplosions() {
            const currentTime = Date.now();
            explosions = explosions.filter(explosion => {
                const elapsed = currentTime - explosion.startTime;
                const duration = 500; // 500ms explosion animation

                if (elapsed >= duration) {
                    return false;
                }

                // Expand radius and fade out
                const progress = elapsed / duration;
                explosion.radius = explosion.maxRadius * progress;
                explosion.opacity = 1 - progress;

                return true;
            });
        }

        function updateWingplanes() {
            wingplanes = wingplanes.filter(wingplane => {
                if (wingplane.spawning) {
                    // Fly up from bottom
                    wingplane.y -= 5;
                    if (wingplane.y <= wingplane.targetY) {
                        wingplane.spawning = false;
                        wingplane.y = wingplane.targetY;
                    }
                } else {
                    // Follow player
                    if (wingplane.side === 'left') {
                        wingplane.x = player.x - 60;
                    } else {
                        wingplane.x = player.x + player.width + 25;
                    }
                    wingplane.y = player.y + 10;
                }

                // Check collision with enemy bullets - protected by shield if active
                for (let i = enemyBullets.length - 1; i >= 0; i--) {
                    if (checkCollision(wingplane, enemyBullets[i])) {
                        enemyBullets.splice(i, 1);
                        if (shield > 0) {
                            // Shield protects wingplane
                            shield = Math.max(0, shield - 10);
                            updateShieldDisplay();
                        } else {
                            // No shield, wingplane takes damage
                            wingplane.health -= 1;
                        }
                        break;
                    }
                }

                // Check collision with enemies - protected by shield if active
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (checkCollision(wingplane, enemies[i])) {
                        enemies.splice(i, 1);
                        score += 25;
                        document.getElementById('score').textContent = score;
                        if (shield > 0) {
                            // Shield protects wingplane
                            shield = Math.max(0, shield - 10);
                            updateShieldDisplay();
                        } else {
                            // No shield, wingplane takes damage
                            wingplane.health -= 1;
                        }
                        break;
                    }
                }

                return wingplane.health > 0;
            });
        }

        function wingplanesShoot() {
            wingplanes.forEach(wingplane => {
                if (!wingplane.spawning) {
                    const bulletWidth = 5;
                    const bulletHeight = 15;

                    // Wingplanes benefit from fork shot and triple shot buff
                    if (forkShot) {
                        // Fork pattern: 4 bullets in a spread
                        const angles = [-10, -3.5, 3.5, 10]; // degrees
                        angles.forEach(angle => {
                            const radians = angle * Math.PI / 180;
                            bullets.push({
                                x: wingplane.x + wingplane.width / 2 - bulletWidth / 2,
                                y: wingplane.y,
                                width: bulletWidth,
                                height: bulletHeight,
                                speed: 7,
                                velocityX: Math.sin(radians) * 7,
                                velocityY: -Math.cos(radians) * 7,
                                color: '#ffaa00',
                                angled: true
                            });
                        });
                    } else if (tripleShot) {
                        // Center bullet
                        bullets.push({
                            x: wingplane.x + wingplane.width / 2 - bulletWidth / 2,
                            y: wingplane.y,
                            width: bulletWidth,
                            height: bulletHeight,
                            speed: 7,
                            color: '#ffaa00'
                        });
                        // Left bullet
                        bullets.push({
                            x: wingplane.x + wingplane.width / 2 - 12 - bulletWidth / 2,
                            y: wingplane.y,
                            width: bulletWidth,
                            height: bulletHeight,
                            speed: 7,
                            color: '#ffaa00'
                        });
                        // Right bullet
                        bullets.push({
                            x: wingplane.x + wingplane.width / 2 + 7 - bulletWidth / 2,
                            y: wingplane.y,
                            width: bulletWidth,
                            height: bulletHeight,
                            speed: 7,
                            color: '#ffaa00'
                        });
                    } else {
                        bullets.push({
                            x: wingplane.x + wingplane.width / 2 - bulletWidth / 2,
                            y: wingplane.y,
                            width: bulletWidth,
                            height: bulletHeight,
                            speed: 7,
                            color: '#ffaa00'
                        });
                    }
                }
            });
        }

        function updateShieldDisplay() {
            const shieldContainer = document.getElementById('shieldContainer');
            const shieldSpan = document.getElementById('shield');
            const shieldFill = document.getElementById('shieldFill');

            if (shield > 0) {
                shieldContainer.style.display = 'block';
                shieldSpan.textContent = shield;
                // Calculate percentage based on max shield of 200
                const shieldPercentage = (shield / 200) * 100;
                shieldFill.style.width = shieldPercentage + '%';
            } else {
                shieldContainer.style.display = 'none';
            }
        }

        function updatePlayer() {
            if (keys['ArrowLeft'] && player.x > 0) {
                player.x -= player.speed;
            }
            if (keys['ArrowRight'] && player.x < canvas.width - player.width) {
                player.x += player.speed;
            }
            if (keys['ArrowUp'] && player.y > 0) {
                player.y -= player.speed;
            }
            if (keys['ArrowDown'] && player.y < canvas.height - player.height) {
                player.y += player.speed;
            }
        }

        function updateBullets() {
            bullets = bullets.filter(bullet => {
                if (bullet.angled) {
                    // Angled bullets use velocity
                    bullet.x += bullet.velocityX;
                    bullet.y += bullet.velocityY;
                    // Keep bullets that are still on screen
                    return bullet.y > 0 && bullet.x > 0 && bullet.x < canvas.width;
                } else {
                    // Normal bullets move straight up
                    bullet.y -= bullet.speed;
                    return bullet.y > 0;
                }
            });
        }

        function updateEnemies() {
            const currentTime = Date.now();
            enemies = enemies.filter(enemy => {
                enemy.y += enemy.speed;
                enemy.x += enemy.horizontalSpeed;

                // Bounce off walls
                if (enemy.x <= 0 || enemy.x >= canvas.width - enemy.width) {
                    enemy.horizontalSpeed *= -1;
                }

                // Enemy shooting
                if (enemy.canShoot && currentTime - enemy.lastShot > 1500) {
                    enemyShoot(enemy);
                    enemy.lastShot = currentTime;
                }

                // Check collision with player
                if (checkCollision(player, enemy)) {
                    if (shield > 0) {
                        shield = Math.max(0, shield - 10);
                        updateShieldDisplay();
                    } else {
                        health -= 20;
                        document.getElementById('health').textContent = health;
                        if (health <= 0) {
                            endGame();
                        }
                    }
                    return false;
                }

                return enemy.y < canvas.height;
            });
        }

        function enemyShoot(enemy) {
            enemyBullets.push({
                x: enemy.x + enemy.width / 2 - 2.5,
                y: enemy.y + enemy.height,
                width: 5,
                height: 15,
                speed: 4,
                color: '#ff9900'
            });
        }

        function updateEnemyBullets() {
            enemyBullets = enemyBullets.filter(bullet => {
                bullet.y += bullet.speed;

                // Check collision with player
                if (checkCollision(player, bullet)) {
                    if (shield > 0) {
                        shield = Math.max(0, shield - 10);
                        updateShieldDisplay();
                    } else {
                        health -= 10;
                        document.getElementById('health').textContent = health;
                        if (health <= 0) {
                            endGame();
                        }
                    }
                    return false;
                }

                return bullet.y < canvas.height;
            });
        }

        function checkCollision(rect1, rect2) {
            return rect1.x < rect2.x + rect2.width &&
                   rect1.x + rect1.width > rect2.x &&
                   rect1.y < rect2.y + rect2.height &&
                   rect1.y + rect1.height > rect2.y;
        }

        function checkBulletCollisions() {
            bullets = bullets.filter(bullet => {
                for (let i = enemies.length - 1; i >= 0; i--) {
                    if (checkCollision(bullet, enemies[i])) {
                        const enemy = enemies[i];

                        // Reduce enemy health
                        enemy.health -= 1;

                        if (enemy.health <= 0) {
                            // Enemy destroyed
                            enemies.splice(i, 1);

                            // Award points based on enemy type
                            if (enemy.type === 'tank') {
                                score += 75; // Tank worth 3x
                            } else if (enemy.type === 'fast') {
                                score += 50; // Fast worth 2x
                            } else {
                                score += 25; // Normal/shooter
                            }

                            document.getElementById('score').textContent = score;
                        }

                        return false; // Bullet consumed
                    }
                }
                return true;
            });
        }

        function startAutoScore() {
            if (scoreInterval) {
                clearInterval(scoreInterval);
            }
            scoreInterval = setInterval(() => {
                if (gameRunning) {
                    score += 15;
                    document.getElementById('score').textContent = score;
                }
            }, 1000);
        }

        function drawPlayer() {
            // Draw shield if active
            if (shield > 0) {
                const shieldRadius = player.width * 0.9;
                const shieldOpacity = Math.min(shield / 100, 1);

                // Outer shield glow
                ctx.strokeStyle = `rgba(0, 212, 255, ${shieldOpacity * 0.6})`;
                ctx.lineWidth = 4;
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, shieldRadius, 0, Math.PI * 2);
                ctx.stroke();

                // Inner shield
                ctx.strokeStyle = `rgba(0, 255, 255, ${shieldOpacity * 0.4})`;
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.arc(player.x + player.width / 2, player.y + player.height / 2, shieldRadius - 5, 0, Math.PI * 2);
                ctx.stroke();

                // Shield sparkles
                for (let i = 0; i < 6; i++) {
                    const angle = (Date.now() / 1000 + i * Math.PI / 3) % (Math.PI * 2);
                    const sparkleX = player.x + player.width / 2 + Math.cos(angle) * shieldRadius;
                    const sparkleY = player.y + player.height / 2 + Math.sin(angle) * shieldRadius;
                    ctx.fillStyle = `rgba(255, 255, 255, ${shieldOpacity * 0.8})`;
                    ctx.beginPath();
                    ctx.arc(sparkleX, sparkleY, 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            }

            // Draw player
            ctx.fillStyle = player.color;
            ctx.beginPath();
            ctx.moveTo(player.x + player.width / 2, player.y);
            ctx.lineTo(player.x, player.y + player.height);
            ctx.lineTo(player.x + player.width, player.y + player.height);
            ctx.closePath();
            ctx.fill();
        }

        function drawBullets() {
            bullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                // Draw player bullets as circles
                const radius = Math.max(bullet.width, bullet.height) / 2;
                ctx.beginPath();
                ctx.arc(bullet.x + bullet.width / 2, bullet.y + bullet.height / 2, radius, 0, Math.PI * 2);
                ctx.fill();
            });

            enemyBullets.forEach(bullet => {
                ctx.fillStyle = bullet.color;
                ctx.fillRect(bullet.x, bullet.y, bullet.width, bullet.height);
            });
        }

        function drawEnemies() {
            enemies.forEach(enemy => {
                ctx.fillStyle = enemy.color;

                // Draw different shapes based on enemy type
                if (enemy.type === 'tank') {
                    // Tank: Large square with armor plating
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

                    // Draw armor indicator
                    ctx.strokeStyle = '#ffffff';
                    ctx.lineWidth = 3;
                    ctx.strokeRect(enemy.x + 5, enemy.y + 5, enemy.width - 10, enemy.height - 10);

                    // Draw health bar background
                    ctx.fillStyle = '#000000';
                    ctx.fillRect(enemy.x, enemy.y - 8, enemy.width, 6);

                    // Draw health bar
                    const healthPercent = enemy.health / enemy.maxHealth;
                    const healthBarWidth = enemy.width * healthPercent;

                    // Color changes based on health
                    if (healthPercent > 0.6) {
                        ctx.fillStyle = '#00ff00'; // Green
                    } else if (healthPercent > 0.3) {
                        ctx.fillStyle = '#ffff00'; // Yellow
                    } else {
                        ctx.fillStyle = '#ff0000'; // Red
                    }
                    ctx.fillRect(enemy.x, enemy.y - 8, healthBarWidth, 6);
                } else if (enemy.type === 'fast') {
                    // Fast: Diamond shape
                    ctx.beginPath();
                    ctx.moveTo(enemy.x + enemy.width / 2, enemy.y);
                    ctx.lineTo(enemy.x + enemy.width, enemy.y + enemy.height / 2);
                    ctx.lineTo(enemy.x + enemy.width / 2, enemy.y + enemy.height);
                    ctx.lineTo(enemy.x, enemy.y + enemy.height / 2);
                    ctx.closePath();
                    ctx.fill();

                    // Show health bar if maxHealth is 2
                    if (enemy.maxHealth === 2 && enemy.health < enemy.maxHealth) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(enemy.x, enemy.y - 6, enemy.width, 4);
                        ctx.fillStyle = '#00ff00';
                        const healthBarWidth = (enemy.health / enemy.maxHealth) * enemy.width;
                        ctx.fillRect(enemy.x, enemy.y - 6, healthBarWidth, 4);
                    }
                } else {
                    // Normal/Shooter: Rectangle
                    ctx.fillRect(enemy.x, enemy.y, enemy.width, enemy.height);

                    // Draw indicator for shooting enemies
                    if (enemy.canShoot) {
                        ctx.fillStyle = '#ffff00';
                        ctx.fillRect(enemy.x + enemy.width / 2 - 3, enemy.y + 5, 6, 6);
                    }

                    // Show health bar if maxHealth is 2
                    if (enemy.maxHealth === 2 && enemy.health < enemy.maxHealth) {
                        ctx.fillStyle = '#000000';
                        ctx.fillRect(enemy.x, enemy.y - 6, enemy.width, 4);
                        ctx.fillStyle = '#00ff00';
                        const healthBarWidth = (enemy.health / enemy.maxHealth) * enemy.width;
                        ctx.fillRect(enemy.x, enemy.y - 6, healthBarWidth, 4);
                    }
                }
            });
        }

        function drawPowerups() {
            powerups.forEach(powerup => {
                // Draw background circle
                ctx.fillStyle = powerup.color;
                ctx.beginPath();
                ctx.arc(powerup.x + powerup.width / 2, powerup.y + powerup.height / 2, powerup.width / 2, 0, Math.PI * 2);
                ctx.fill();

                // Draw icon based on type
                ctx.fillStyle = '#000000';
                ctx.font = 'bold 24px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                let icon = '';
                if (powerup.type === 'A') {
                    icon = '‚ö°'; // Lightning for speed
                } else if (powerup.type === 'B') {
                    icon = '‚öîÔ∏è'; // Crossed swords for triple shot
                } else if (powerup.type === 'C') {
                    icon = '‚ù§Ô∏è'; // Heart for health/shield
                } else if (powerup.type === 'D') {
                    icon = '‚úàÔ∏è'; // Plane for wingplanes
                } else if (powerup.type === 'F') {
                    icon = 'üöÄ'; // Rocket for missiles
                }

                ctx.fillText(icon, powerup.x + powerup.width / 2, powerup.y + powerup.height / 2);
            });
        }

        function drawWingplanes() {
            wingplanes.forEach(wingplane => {
                // Draw shield if player has shield and wingplane is active
                if (shield > 0 && !wingplane.spawning) {
                    const shieldRadius = wingplane.width * 0.7;
                    const shieldOpacity = Math.min(shield / 100, 1) * 0.6;

                    // Outer shield glow
                    ctx.strokeStyle = `rgba(0, 212, 255, ${shieldOpacity * 0.6})`;
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.arc(wingplane.x + wingplane.width / 2, wingplane.y + wingplane.height / 2, shieldRadius, 0, Math.PI * 2);
                    ctx.stroke();

                    // Inner shield
                    ctx.strokeStyle = `rgba(0, 255, 255, ${shieldOpacity * 0.4})`;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(wingplane.x + wingplane.width / 2, wingplane.y + wingplane.height / 2, shieldRadius - 3, 0, Math.PI * 2);
                    ctx.stroke();
                }

                // Draw wingplane
                ctx.fillStyle = wingplane.color;
                ctx.beginPath();
                ctx.moveTo(wingplane.x + wingplane.width / 2, wingplane.y);
                ctx.lineTo(wingplane.x, wingplane.y + wingplane.height);
                ctx.lineTo(wingplane.x + wingplane.width, wingplane.y + wingplane.height);
                ctx.closePath();
                ctx.fill();
            });
        }

        function drawBomberPlanes() {
            bomberPlanes.forEach(bomber => {
                // Draw bomber plane (larger triangle)
                ctx.fillStyle = bomber.color;
                ctx.beginPath();
                ctx.moveTo(bomber.x + bomber.width / 2, bomber.y);
                ctx.lineTo(bomber.x, bomber.y + bomber.height);
                ctx.lineTo(bomber.x + bomber.width, bomber.y + bomber.height);
                ctx.closePath();
                ctx.fill();

                // Draw indicator stripe
                ctx.fillStyle = '#ffffff';
                ctx.fillRect(bomber.x + bomber.width / 4, bomber.y + bomber.height / 2, bomber.width / 2, 4);
            });
        }

        function drawExplosions() {
            explosions.forEach(explosion => {
                // Draw expanding explosion ring
                ctx.strokeStyle = `rgba(255, 100, 0, ${explosion.opacity})`;
                ctx.lineWidth = 5;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius, 0, Math.PI * 2);
                ctx.stroke();

                // Draw inner bright flash
                ctx.fillStyle = `rgba(255, 200, 0, ${explosion.opacity * 0.5})`;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * 0.6, 0, Math.PI * 2);
                ctx.fill();

                // Draw outer glow
                ctx.strokeStyle = `rgba(255, 150, 0, ${explosion.opacity * 0.3})`;
                ctx.lineWidth = 8;
                ctx.beginPath();
                ctx.arc(explosion.x, explosion.y, explosion.radius * 1.2, 0, Math.PI * 2);
                ctx.stroke();
            });
        }

        function drawStars() {
            ctx.fillStyle = 'white';
            for (let i = 0; i < 50; i++) {
                const x = Math.random() * canvas.width;
                const y = Math.random() * canvas.height;
                ctx.fillRect(x, y, 2, 2);
            }
        }

        function endGame() {
            gameRunning = false;
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
            }
            if (scoreInterval) {
                clearInterval(scoreInterval);
            }
            document.getElementById('finalScore').textContent = score;
            document.getElementById('gameOver').style.display = 'block';
        }

        function restartGame() {
            player.x = canvas.width / 2 - 25;
            player.y = canvas.height - 80;
            bullets = [];
            enemies = [];
            enemyBullets = [];
            powerups = [];
            wingplanes = [];
            bomberPlanes = [];
            explosions = [];
            missiles = [];
            missileParticles = [];
            missileCount = 0;
            hasShownMissilePrompt = false;
            boss = null;
            bossSpawned = false;
            score = 0;
            health = 100;
            shield = 0;
            fireRate = 200;
            tripleShot = false;
            forkShot = false;
            collectedBuffTypes.clear();
            buffCollectionCount = { A: 0, B: 0, C: 0, D: 0, F: 0 };
            gameRunning = true;
            document.getElementById('score').textContent = score;
            document.getElementById('health').textContent = health;
            updateShieldDisplay();
            updateMissileDisplay();
            document.getElementById('gameOver').style.display = 'none';
            startAutoFire();
            startAutoScore();
            gameLoop();
        }

        function startAutoFire() {
            if (autoFireInterval) {
                clearInterval(autoFireInterval);
            }
            autoFireInterval = setInterval(() => {
                if (gameRunning) {
                    shootBullet();
                    wingplanesShoot();
                }
            }, fireRate);
        }

        function spawnBoss() {
            boss = {
                x: canvas.width / 2 - 125,
                y: -300,
                width: 250,
                height: 150,
                speed: 0.4,
                health: 1500,
                maxHealth: 1500,
                type: 'boss',
                phase: 1,
                lastShot: 0,
                lastPatternChange: Date.now(),
                shootingPattern: 0,
                moveDirection: 1
            };
        }

        function updateBoss() {
            if (!boss) return;

            // Boss entrance - move down until at top of screen
            if (boss.y < 50) {
                boss.y += boss.speed;
            } else {
                // Horizontal movement pattern
                boss.x += boss.speed * boss.moveDirection * 2;

                // Bounce off walls
                if (boss.x <= 0 || boss.x >= canvas.width - boss.width) {
                    boss.moveDirection *= -1;
                }

                // Change shooting pattern every second
                const currentTime = Date.now();
                if (currentTime - boss.lastPatternChange >= 1000) {
                    // Weighted random: fork pattern has slightly higher chance
                    const rand = Math.random();
                    if (rand < 0.25) {
                        boss.shootingPattern = 5; // Fork pattern (25% chance)
                    } else {
                        boss.shootingPattern = Math.floor(Math.random() * 5); // Other patterns (75% chance, ~15% each)
                    }
                    boss.lastPatternChange = currentTime;
                }

                // Boss shooting pattern
                if (currentTime - boss.lastShot >= 600) {
                    bossShoot();
                    boss.lastShot = currentTime;
                }
            }

            // Check collision with player
            if (checkCollision(player, boss)) {
                if (shield > 0) {
                    shield = Math.max(0, shield - 20);
                    updateShieldDisplay();
                } else {
                    health -= 30;
                    document.getElementById('health').textContent = health;
                    if (health <= 0) {
                        endGame();
                    }
                }
            }
        }

        function bossShoot() {
            if (!boss) return;

            const centerX = boss.x + boss.width / 2;
            const centerY = boss.y + boss.height;

            switch(boss.shootingPattern) {
                case 0: // Spread pattern - 5 bullets wide
                    for (let i = -2; i <= 2; i++) {
                        enemyBullets.push({
                            x: centerX - 3.5 + (i * 40),
                            y: centerY,
                            width: 7,
                            height: 20,
                            speed: 5,
                            color: '#ff0000'
                        });
                    }
                    break;

                case 1: // Aimed at player
                    const dx = player.x + player.width / 2 - centerX;
                    const dy = player.y - centerY;
                    const angle = Math.atan2(dy, dx);

                    for (let i = -1; i <= 1; i++) {
                        const bulletAngle = angle + (i * 0.2);
                        enemyBullets.push({
                            x: centerX - 3.5,
                            y: centerY,
                            width: 7,
                            height: 20,
                            speed: 6,
                            velocityX: Math.cos(bulletAngle) * 6,
                            velocityY: Math.sin(bulletAngle) * 6,
                            color: '#ff00ff',
                            angled: true
                        });
                    }
                    break;

                case 2: // Circular spray
                    for (let i = 0; i < 8; i++) {
                        const angle = (i / 8) * Math.PI * 2;
                        enemyBullets.push({
                            x: centerX - 3.5,
                            y: centerY,
                            width: 7,
                            height: 20,
                            speed: 4,
                            velocityX: Math.cos(angle) * 4,
                            velocityY: Math.sin(angle) * 4,
                            color: '#ffff00',
                            angled: true
                        });
                    }
                    break;

                case 3: // Wave pattern - alternating
                    for (let i = -3; i <= 3; i++) {
                        const offsetY = Math.sin(Date.now() / 200 + i) * 20;
                        enemyBullets.push({
                            x: centerX - 3.5 + (i * 30),
                            y: centerY + offsetY,
                            width: 7,
                            height: 20,
                            speed: 5,
                            color: '#00ffff'
                        });
                    }
                    break;

                case 4: // Rapid fire downward
                    for (let i = 0; i < 3; i++) {
                        enemyBullets.push({
                            x: centerX - 3.5 + ((i - 1) * 15),
                            y: centerY,
                            width: 7,
                            height: 20,
                            speed: 7,
                            color: '#ff8800'
                        });
                    }
                    break;

                case 5: // Fork pattern - two-way fork with wide angles
                    // Wide fork pattern with bigger angles than player
                    const forkAngles = [-40, -25, -12, 12, 25, 40]; // Wider spread

                    forkAngles.forEach(angleDeg => {
                        const angleRad = angleDeg * Math.PI / 180;
                        enemyBullets.push({
                            x: centerX - 3.5,
                            y: centerY,
                            width: 7,
                            height: 20,
                            speed: 5,
                            velocityX: Math.sin(angleRad) * 5,
                            velocityY: Math.cos(angleRad) * 5,
                            color: '#00ff00',
                            angled: true
                        });
                    });
                    break;
            }
        }

        function checkBossBulletCollisions() {
            if (!boss) return;

            bullets = bullets.filter(bullet => {
                if (checkCollision(bullet, boss)) {
                    boss.health -= 1;

                    if (boss.health <= 0) {
                        score += 5000;
                        document.getElementById('score').textContent = score;
                        boss = null;
                        // Game over when boss is defeated
                        gameRunning = false;
                        document.getElementById('finalScore').textContent = score;
                        document.getElementById('gameOver').style.display = 'flex';
                    }
                    return false;
                }
                return true;
            });
        }

        function drawBoss() {
            if (!boss) return;

            // Draw UFO body - main saucer
            const centerX = boss.x + boss.width / 2;
            const centerY = boss.y + boss.height / 2;

            // Bottom dome
            const gradient1 = ctx.createRadialGradient(centerX, centerY + 20, 0, centerX, centerY + 20, boss.width / 2);
            gradient1.addColorStop(0, '#666666');
            gradient1.addColorStop(1, '#333333');
            ctx.fillStyle = gradient1;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY + 20, boss.width / 2, boss.height / 3, 0, 0, Math.PI * 2);
            ctx.fill();

            // Main saucer body
            const gradient2 = ctx.createLinearGradient(boss.x, boss.y, boss.x, boss.y + boss.height);
            gradient2.addColorStop(0, '#888888');
            gradient2.addColorStop(0.5, '#aaaaaa');
            gradient2.addColorStop(1, '#666666');
            ctx.fillStyle = gradient2;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, boss.width / 2, boss.height / 2.5, 0, 0, Math.PI * 2);
            ctx.fill();

            // UFO edge/rim with lights
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 6;
            ctx.beginPath();
            ctx.ellipse(centerX, centerY, boss.width / 2, boss.height / 2.5, 0, 0, Math.PI * 2);
            ctx.stroke();

            // Draw UFO lights around the rim
            const numLights = 12;
            for (let i = 0; i < numLights; i++) {
                const angle = (i / numLights) * Math.PI * 2;
                const lightX = centerX + Math.cos(angle) * (boss.width / 2);
                const lightY = centerY + Math.sin(angle) * (boss.height / 2.5);

                // Alternating colors
                const lightColor = i % 2 === 0 ? '#00ff00' : '#ff00ff';
                ctx.fillStyle = lightColor;
                ctx.beginPath();
                ctx.arc(lightX, lightY, 5, 0, Math.PI * 2);
                ctx.fill();
            }

            // Top dome/cockpit
            const gradient3 = ctx.createRadialGradient(centerX, boss.y + 30, 0, centerX, boss.y + 30, 40);
            gradient3.addColorStop(0, '#ff0000');
            gradient3.addColorStop(0.5, '#cc0000');
            gradient3.addColorStop(1, '#880000');
            ctx.fillStyle = gradient3;
            ctx.beginPath();
            ctx.arc(centerX, boss.y + 30, 40, 0, Math.PI * 2);
            ctx.fill();

            // Cockpit window
            ctx.fillStyle = 'rgba(0, 255, 255, 0.5)';
            ctx.beginPath();
            ctx.arc(centerX, boss.y + 30, 25, 0, Math.PI * 2);
            ctx.fill();

            // Draw health bar above boss
            const barWidth = boss.width + 40;
            const barHeight = 15;
            const barX = boss.x - 20;
            const barY = boss.y - 30;

            // Background
            ctx.fillStyle = '#000000';
            ctx.fillRect(barX, barY, barWidth, barHeight);

            // Health fill
            const healthPercent = boss.health / boss.maxHealth;
            const healthBarWidth = barWidth * healthPercent;

            if (healthPercent > 0.6) {
                ctx.fillStyle = '#00ff00';
            } else if (healthPercent > 0.3) {
                ctx.fillStyle = '#ffff00';
            } else {
                ctx.fillStyle = '#ff0000';
            }
            ctx.fillRect(barX, barY, healthBarWidth, barHeight);

            // Border
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 2;
            ctx.strokeRect(barX, barY, barWidth, barHeight);

            // HP text
            ctx.fillStyle = '#ffffff';
            ctx.font = 'bold 20px Arial';
            ctx.textAlign = 'center';
            ctx.fillText(`UFO BOSS: ${boss.health}/${boss.maxHealth}`, boss.x + boss.width / 2, barY - 10);
        }

        function gameLoop() {
            if (!gameRunning) return;

            // Spawn boss at 15000 score (only once per game)
            if (score >= 15000 && !bossSpawned) {
                spawnBoss();
                bossSpawned = true;
            }

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            drawStars();
            updatePlayer();
            updateBullets();
            updateEnemies();
            updateBoss();
            updateEnemyBullets();
            updatePowerups();
            updateWingplanes();
            updateBomberPlanes();
            updateExplosions();
            updateMissiles();
            updateMissileParticles();
            checkBulletCollisions();
            checkBossBulletCollisions();

            drawBoss();
            drawPlayer();
            drawWingplanes();
            drawBomberPlanes();
            drawExplosions();
            drawBullets();
            drawEnemies();
            drawPowerups();
            drawMissiles();

            requestAnimationFrame(gameLoop);
        }

        // Spawn enemies periodically - increases with score
        setInterval(() => {
            if (gameRunning) {
                // Reduce enemy spawns when boss is active
                if (boss) {
                    // Spawn 2 enemies when boss is present
                    if (Math.random() < 0.5) { // 50% chance
                        createEnemy();
                        createEnemy();
                    }
                } else {
                    // Start with 2 enemies, gradually increase to 10 based on score
                    const baseEnemies = 2;
                    const bonusEnemies = Math.min(Math.floor(score / 1000), 8); // Up to 8 bonus enemies
                    const totalEnemies = baseEnemies + bonusEnemies;

                    for (let i = 0; i < totalEnemies; i++) {
                        createEnemy();
                    }
                }
            }
        }, 800);

        // Spawn powerups periodically - base 5 seconds, increases with score
        setInterval(() => {
            if (gameRunning) {
                // Calculate spawn chance based on score
                let baseChance = 0.6; // 60% base chance
                const scoreBonus = Math.min(score / 3000, 0.4); // Up to 40% bonus at 3000+ score

                // Sharply increase probability when player has < 4 buffs
                const activeBuffCount = Object.values(buffCollectionCount).filter(count => count > 0).length;
                if (activeBuffCount < 4) {
                    // Sharp increase based on how few buffs the player has
                    if (activeBuffCount === 0) {
                        baseChance = 0.95; // 95% chance with no buffs
                    } else if (activeBuffCount === 1) {
                        baseChance = 0.90; // 90% chance with 1 buff
                    } else if (activeBuffCount === 2) {
                        baseChance = 0.85; // 85% chance with 2 buffs
                    } else if (activeBuffCount === 3) {
                        baseChance = 0.75; // 75% chance with 3 buffs
                    }
                }

                const spawnChance = Math.min(baseChance + scoreBonus, 1.0); // Cap at 100%

                if (Math.random() < spawnChance) {
                    createPowerup();
                }
            }
        }, 5000);

        // Start auto-fire
        startAutoFire();

        // Start auto-score
        startAutoScore();

        // Start game
        gameLoop();
    </script>
</body>
</html>
